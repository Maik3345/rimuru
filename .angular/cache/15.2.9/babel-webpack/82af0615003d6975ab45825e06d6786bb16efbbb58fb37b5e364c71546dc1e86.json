{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport doctrine from 'doctrine';\nfunction containsJsDoc(value) {\n  return value != null && value.includes('@');\n}\nfunction parse(content, tags) {\n  var ast;\n  try {\n    ast = doctrine.parse(content, {\n      tags: tags,\n      sloppy: true\n    });\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    throw new Error('Cannot parse JSDoc tags.');\n  }\n  return ast;\n}\nvar DEFAULT_OPTIONS = {\n  tags: ['param', 'arg', 'argument', 'returns', 'ignore']\n};\nexport var parseJsDoc = function parseJsDoc(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_OPTIONS;\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n  var jsDocAst = parse(value, options.tags);\n  var extractedTags = extractJsDocTags(jsDocAst);\n  if (extractedTags.ignore) {\n    // There is no point in doing other stuff since this prop will not be rendered.\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description,\n    extractedTags: extractedTags\n  };\n};\nfunction extractJsDocTags(ast) {\n  var extractedTags = {\n    params: null,\n    returns: null,\n    ignore: false\n  };\n  for (var i = 0; i < ast.tags.length; i += 1) {\n    var tag = ast.tags[i];\n    if (tag.title === 'ignore') {\n      extractedTags.ignore = true; // Once we reach an @ignore tag, there is no point in parsing the other tags since we will not render the prop.\n\n      break;\n    } else {\n      switch (tag.title) {\n        // arg & argument are aliases for param.\n        case 'param':\n        case 'arg':\n        case 'argument':\n          {\n            var paramTag = extractParam(tag);\n            if (paramTag != null) {\n              if (extractedTags.params == null) {\n                extractedTags.params = [];\n              }\n              extractedTags.params.push(paramTag);\n            }\n            break;\n          }\n        case 'returns':\n          {\n            var returnsTag = extractReturns(tag);\n            if (returnsTag != null) {\n              extractedTags.returns = returnsTag;\n            }\n            break;\n          }\n        default:\n          break;\n      }\n    }\n  }\n  return extractedTags;\n}\nfunction extractParam(tag) {\n  var paramName = tag.name; // When the @param doesn't have a name but have a type and a description, \"null-null\" is returned.\n\n  if (paramName != null && paramName !== 'null-null') {\n    return {\n      name: tag.name,\n      type: tag.type,\n      description: tag.description,\n      getPrettyName: function getPrettyName() {\n        if (paramName.includes('null')) {\n          // There is a few cases in which the returned param name contains \"null\".\n          // - @param {SyntheticEvent} event- Original SyntheticEvent\n          // - @param {SyntheticEvent} event.\\n@returns {string}\n          return paramName.replace('-null', '').replace('.null', '');\n        }\n        return tag.name;\n      },\n      getTypeName: function getTypeName() {\n        return tag.type != null ? extractTypeName(tag.type) : null;\n      }\n    };\n  }\n  return null;\n}\nfunction extractReturns(tag) {\n  if (tag.type != null) {\n    return {\n      type: tag.type,\n      description: tag.description,\n      getTypeName: function getTypeName() {\n        return extractTypeName(tag.type);\n      }\n    };\n  }\n  return null;\n}\nfunction extractTypeName(type) {\n  if (type.type === 'NameExpression') {\n    return type.name;\n  }\n  if (type.type === 'RecordType') {\n    var recordFields = type.fields.map(function (field) {\n      if (field.value != null) {\n        var valueTypeName = extractTypeName(field.value);\n        return \"\".concat(field.key, \": \").concat(valueTypeName);\n      }\n      return field.key;\n    });\n    return \"({\".concat(recordFields.join(', '), \"})\");\n  }\n  if (type.type === 'UnionType') {\n    var unionElements = type.elements.map(extractTypeName);\n    return \"(\".concat(unionElements.join('|'), \")\");\n  } // Only support untyped array: []. Might add more support later if required.\n\n  if (type.type === 'ArrayType') {\n    return '[]';\n  }\n  if (type.type === 'TypeApplication') {\n    if (type.expression != null) {\n      if (type.expression.name === 'Array') {\n        var arrayType = extractTypeName(type.applications[0]);\n        return \"\".concat(arrayType, \"[]\");\n      }\n    }\n  }\n  if (type.type === 'NullableType' || type.type === 'NonNullableType' || type.type === 'OptionalType') {\n    return extractTypeName(type.expression);\n  }\n  if (type.type === 'AllLiteral') {\n    return 'any';\n  }\n  return null;\n}","map":{"version":3,"names":["doctrine","containsJsDoc","value","includes","parse","content","tags","ast","sloppy","e","console","error","Error","DEFAULT_OPTIONS","parseJsDoc","options","arguments","length","undefined","includesJsDoc","ignore","jsDocAst","extractedTags","extractJsDocTags","description","params","returns","i","tag","title","paramTag","extractParam","push","returnsTag","extractReturns","paramName","name","type","getPrettyName","replace","getTypeName","extractTypeName","recordFields","fields","map","field","valueTypeName","concat","key","join","unionElements","elements","expression","arrayType","applications"],"sources":["/Users/michael.restrepo/code/personal/web-components/rimuru/node_modules/@storybook/docs-tools/dist/esm/argTypes/jsdocParser.js"],"sourcesContent":["import \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport doctrine from 'doctrine';\n\nfunction containsJsDoc(value) {\n  return value != null && value.includes('@');\n}\n\nfunction parse(content, tags) {\n  var ast;\n\n  try {\n    ast = doctrine.parse(content, {\n      tags: tags,\n      sloppy: true\n    });\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    throw new Error('Cannot parse JSDoc tags.');\n  }\n\n  return ast;\n}\n\nvar DEFAULT_OPTIONS = {\n  tags: ['param', 'arg', 'argument', 'returns', 'ignore']\n};\nexport var parseJsDoc = function parseJsDoc(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_OPTIONS;\n\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n\n  var jsDocAst = parse(value, options.tags);\n  var extractedTags = extractJsDocTags(jsDocAst);\n\n  if (extractedTags.ignore) {\n    // There is no point in doing other stuff since this prop will not be rendered.\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description,\n    extractedTags: extractedTags\n  };\n};\n\nfunction extractJsDocTags(ast) {\n  var extractedTags = {\n    params: null,\n    returns: null,\n    ignore: false\n  };\n\n  for (var i = 0; i < ast.tags.length; i += 1) {\n    var tag = ast.tags[i];\n\n    if (tag.title === 'ignore') {\n      extractedTags.ignore = true; // Once we reach an @ignore tag, there is no point in parsing the other tags since we will not render the prop.\n\n      break;\n    } else {\n      switch (tag.title) {\n        // arg & argument are aliases for param.\n        case 'param':\n        case 'arg':\n        case 'argument':\n          {\n            var paramTag = extractParam(tag);\n\n            if (paramTag != null) {\n              if (extractedTags.params == null) {\n                extractedTags.params = [];\n              }\n\n              extractedTags.params.push(paramTag);\n            }\n\n            break;\n          }\n\n        case 'returns':\n          {\n            var returnsTag = extractReturns(tag);\n\n            if (returnsTag != null) {\n              extractedTags.returns = returnsTag;\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }\n\n  return extractedTags;\n}\n\nfunction extractParam(tag) {\n  var paramName = tag.name; // When the @param doesn't have a name but have a type and a description, \"null-null\" is returned.\n\n  if (paramName != null && paramName !== 'null-null') {\n    return {\n      name: tag.name,\n      type: tag.type,\n      description: tag.description,\n      getPrettyName: function getPrettyName() {\n        if (paramName.includes('null')) {\n          // There is a few cases in which the returned param name contains \"null\".\n          // - @param {SyntheticEvent} event- Original SyntheticEvent\n          // - @param {SyntheticEvent} event.\\n@returns {string}\n          return paramName.replace('-null', '').replace('.null', '');\n        }\n\n        return tag.name;\n      },\n      getTypeName: function getTypeName() {\n        return tag.type != null ? extractTypeName(tag.type) : null;\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction extractReturns(tag) {\n  if (tag.type != null) {\n    return {\n      type: tag.type,\n      description: tag.description,\n      getTypeName: function getTypeName() {\n        return extractTypeName(tag.type);\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction extractTypeName(type) {\n  if (type.type === 'NameExpression') {\n    return type.name;\n  }\n\n  if (type.type === 'RecordType') {\n    var recordFields = type.fields.map(function (field) {\n      if (field.value != null) {\n        var valueTypeName = extractTypeName(field.value);\n        return \"\".concat(field.key, \": \").concat(valueTypeName);\n      }\n\n      return field.key;\n    });\n    return \"({\".concat(recordFields.join(', '), \"})\");\n  }\n\n  if (type.type === 'UnionType') {\n    var unionElements = type.elements.map(extractTypeName);\n    return \"(\".concat(unionElements.join('|'), \")\");\n  } // Only support untyped array: []. Might add more support later if required.\n\n\n  if (type.type === 'ArrayType') {\n    return '[]';\n  }\n\n  if (type.type === 'TypeApplication') {\n    if (type.expression != null) {\n      if (type.expression.name === 'Array') {\n        var arrayType = extractTypeName(type.applications[0]);\n        return \"\".concat(arrayType, \"[]\");\n      }\n    }\n  }\n\n  if (type.type === 'NullableType' || type.type === 'NonNullableType' || type.type === 'OptionalType') {\n    return extractTypeName(type.expression);\n  }\n\n  if (type.type === 'AllLiteral') {\n    return 'any';\n  }\n\n  return null;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}