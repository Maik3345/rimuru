{"ast":null,"code":"//! stable.js 0.1.8, https://github.com/Two-Screen/stable\n//! © 2018 Angry Bytes and contributors. MIT licensed.\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.stable = factory();\n})(this, function () {\n  'use strict';\n\n  // A stable array sort, because `Array#sort()` is not guaranteed stable.\n  // This is an implementation of merge sort, without recursion.\n  var stable = function (arr, comp) {\n    return exec(arr.slice(), comp);\n  };\n  stable.inplace = function (arr, comp) {\n    var result = exec(arr, comp);\n\n    // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n    if (result !== arr) {\n      pass(result, null, arr.length, arr);\n    }\n    return arr;\n  };\n\n  // Execute the sort using the input array and a second buffer as work space.\n  // Returns one of those two, containing the final result.\n  function exec(arr, comp) {\n    if (typeof comp !== 'function') {\n      comp = function (a, b) {\n        return String(a).localeCompare(b);\n      };\n    }\n\n    // Short-circuit when there's nothing to sort.\n    var len = arr.length;\n    if (len <= 1) {\n      return arr;\n    }\n\n    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n    var buffer = new Array(len);\n    for (var chk = 1; chk < len; chk *= 2) {\n      pass(arr, comp, chk, buffer);\n      var tmp = arr;\n      arr = buffer;\n      buffer = tmp;\n    }\n    return arr;\n  }\n\n  // Run a single pass with the given chunk size.\n  var pass = function (arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0;\n    // Step size / double chunk size.\n    var dbl = chk * 2;\n    // Bounds of the left and right chunks.\n    var l, r, e;\n    // Iterators over the left and right chunk.\n    var li, ri;\n\n    // Iterate over pairs of chunks.\n    for (l = 0; l < len; l += dbl) {\n      r = l + chk;\n      e = r + chk;\n      if (r > len) r = len;\n      if (e > len) e = len;\n\n      // Iterate both chunks in parallel.\n      li = l;\n      ri = r;\n      while (true) {\n        // Compare the chunks.\n        if (li < r && ri < e) {\n          // This works for a regular `sort()` compatible comparator,\n          // but also for a simple comparator like: `a > b`\n          if (comp(arr[li], arr[ri]) <= 0) {\n            result[i++] = arr[li++];\n          } else {\n            result[i++] = arr[ri++];\n          }\n        }\n        // Nothing to compare, just flush what's left.\n        else if (li < r) {\n          result[i++] = arr[li++];\n        } else if (ri < e) {\n          result[i++] = arr[ri++];\n        }\n        // Both iterators are at the chunk ends.\n        else {\n          break;\n        }\n      }\n    }\n  };\n  return stable;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","stable","arr","comp","exec","slice","inplace","result","pass","length","a","b","String","localeCompare","len","buffer","Array","chk","tmp","i","dbl","l","r","e","li","ri"],"sources":["/Users/michael.restrepo/code/personal/web-components/rimuru/node_modules/stable/stable.js"],"sourcesContent":["//! stable.js 0.1.8, https://github.com/Two-Screen/stable\n//! © 2018 Angry Bytes and contributors. MIT licensed.\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.stable = factory());\n}(this, (function () { 'use strict';\n\n  // A stable array sort, because `Array#sort()` is not guaranteed stable.\n  // This is an implementation of merge sort, without recursion.\n\n  var stable = function (arr, comp) {\n    return exec(arr.slice(), comp)\n  };\n\n  stable.inplace = function (arr, comp) {\n    var result = exec(arr, comp);\n\n    // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n    if (result !== arr) {\n      pass(result, null, arr.length, arr);\n    }\n\n    return arr\n  };\n\n  // Execute the sort using the input array and a second buffer as work space.\n  // Returns one of those two, containing the final result.\n  function exec(arr, comp) {\n    if (typeof(comp) !== 'function') {\n      comp = function (a, b) {\n        return String(a).localeCompare(b)\n      };\n    }\n\n    // Short-circuit when there's nothing to sort.\n    var len = arr.length;\n    if (len <= 1) {\n      return arr\n    }\n\n    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n    var buffer = new Array(len);\n    for (var chk = 1; chk < len; chk *= 2) {\n      pass(arr, comp, chk, buffer);\n\n      var tmp = arr;\n      arr = buffer;\n      buffer = tmp;\n    }\n\n    return arr\n  }\n\n  // Run a single pass with the given chunk size.\n  var pass = function (arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0;\n    // Step size / double chunk size.\n    var dbl = chk * 2;\n    // Bounds of the left and right chunks.\n    var l, r, e;\n    // Iterators over the left and right chunk.\n    var li, ri;\n\n    // Iterate over pairs of chunks.\n    for (l = 0; l < len; l += dbl) {\n      r = l + chk;\n      e = r + chk;\n      if (r > len) r = len;\n      if (e > len) e = len;\n\n      // Iterate both chunks in parallel.\n      li = l;\n      ri = r;\n      while (true) {\n        // Compare the chunks.\n        if (li < r && ri < e) {\n          // This works for a regular `sort()` compatible comparator,\n          // but also for a simple comparator like: `a > b`\n          if (comp(arr[li], arr[ri]) <= 0) {\n            result[i++] = arr[li++];\n          }\n          else {\n            result[i++] = arr[ri++];\n          }\n        }\n        // Nothing to compare, just flush what's left.\n        else if (li < r) {\n          result[i++] = arr[li++];\n        }\n        else if (ri < e) {\n          result[i++] = arr[ri++];\n        }\n        // Both iterators are at the chunk ends.\n        else {\n          break\n        }\n      }\n    }\n  };\n\n  return stable;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}