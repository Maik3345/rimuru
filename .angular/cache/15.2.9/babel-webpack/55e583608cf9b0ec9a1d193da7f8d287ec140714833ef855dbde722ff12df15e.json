{"ast":null,"code":"\"use strict\";\n\n/* eslint-disable no-underscore-dangle */\n/* global window */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractComponentDescription = exports.extractArgTypes = exports.extractArgTypesFromData = exports.extractType = exports.findComponentByName = exports.checkValidCompodocJson = exports.checkValidComponentOrDirective = exports.getCompodocJson = exports.setCompodocJson = exports.isMethod = void 0;\nconst client_logger_1 = require(\"@storybook/client-logger\");\nexports.isMethod = methodOrProp => {\n  return methodOrProp.args !== undefined;\n};\nexports.setCompodocJson = compodocJson => {\n  // @ts-ignore\n  window.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n};\n// @ts-ignore\nexports.getCompodocJson = () => window.__STORYBOOK_COMPODOC_JSON__;\nexports.checkValidComponentOrDirective = component => {\n  if (!component.name) {\n    throw new Error(`Invalid component ${JSON.stringify(component)}`);\n  }\n};\nexports.checkValidCompodocJson = compodocJson => {\n  if (!compodocJson || !compodocJson.components) {\n    throw new Error('Invalid compodoc JSON');\n  }\n};\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find(x => x.name === decoratorName);\nconst mapPropertyToSection = item => {\n  if (hasDecorator(item, 'ViewChild')) {\n    return 'view child';\n  }\n  if (hasDecorator(item, 'ViewChildren')) {\n    return 'view children';\n  }\n  if (hasDecorator(item, 'ContentChild')) {\n    return 'content child';\n  }\n  if (hasDecorator(item, 'ContentChildren')) {\n    return 'content children';\n  }\n  return 'properties';\n};\nconst mapItemToSection = (key, item) => {\n  switch (key) {\n    case 'methods':\n    case 'methodsClass':\n      return 'methods';\n    case 'inputsClass':\n      return 'inputs';\n    case 'outputsClass':\n      return 'outputs';\n    case 'properties':\n    case 'propertiesClass':\n      if (exports.isMethod(item)) {\n        throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n      }\n      return mapPropertyToSection(item);\n    default:\n      throw new Error(`Unknown key: ${key}`);\n  }\n};\nexports.findComponentByName = (name, compodocJson) => compodocJson.components.find(c => c.name === name) || compodocJson.directives.find(c => c.name === name) || compodocJson.pipes.find(c => c.name === name) || compodocJson.injectables.find(c => c.name === name) || compodocJson.classes.find(c => c.name === name);\nconst getComponentData = component => {\n  if (!component) {\n    return null;\n  }\n  exports.checkValidComponentOrDirective(component);\n  const compodocJson = exports.getCompodocJson();\n  if (!compodocJson) {\n    return null;\n  }\n  exports.checkValidCompodocJson(compodocJson);\n  const {\n    name\n  } = component;\n  const metadata = exports.findComponentByName(name, compodocJson);\n  if (!metadata) {\n    client_logger_1.logger.warn(`Component not found in compodoc JSON: '${name}'`);\n  }\n  return metadata;\n};\nconst displaySignature = item => {\n  const args = item.args.map(arg => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n  return `(${args.join(', ')}) => ${item.returnType}`;\n};\nconst extractTypeFromValue = defaultValue => {\n  const valueType = typeof defaultValue;\n  return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string' ? valueType : null;\n};\nconst extractEnumValues = compodocType => {\n  var _a, _b;\n  const compodocJson = exports.getCompodocJson();\n  const enumType = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.enumerations) === null || _b === void 0 ? void 0 : _b.find(x => x.name === compodocType);\n  if (enumType === null || enumType === void 0 ? void 0 : enumType.childs.every(x => x.value)) {\n    return enumType.childs.map(x => x.value);\n  }\n  if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n    return null;\n  }\n  try {\n    return compodocType.split('|').map(value => JSON.parse(value));\n  } catch (e) {\n    return null;\n  }\n};\nexports.extractType = (property, defaultValue) => {\n  const compodocType = property.type || extractTypeFromValue(defaultValue);\n  switch (compodocType) {\n    case 'string':\n    case 'boolean':\n    case 'number':\n      return {\n        name: compodocType\n      };\n    case undefined:\n    case null:\n      return {\n        name: 'void'\n      };\n    default:\n      {\n        const resolvedType = resolveTypealias(compodocType);\n        const enumValues = extractEnumValues(resolvedType);\n        return enumValues ? {\n          name: 'enum',\n          value: enumValues\n        } : {\n          name: 'object'\n        };\n      }\n  }\n};\nconst castDefaultValue = (property, defaultValue) => {\n  const compodocType = property.type;\n  // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n  // null and undefined also have 'any' type\n  if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n    switch (compodocType) {\n      case 'boolean':\n        return defaultValue === 'true';\n      case 'number':\n        return Number(defaultValue);\n      case 'EventEmitter':\n        return undefined;\n      default:\n        return defaultValue;\n    }\n  } else {\n    switch (defaultValue) {\n      case 'true':\n        return true;\n      case 'false':\n        return false;\n      case 'null':\n        return null;\n      case 'undefined':\n        return undefined;\n      default:\n        return defaultValue;\n    }\n  }\n};\nconst extractDefaultValueFromComments = (property, value) => {\n  let commentValue = value;\n  property.jsdoctags.forEach(tag => {\n    if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n      // @ts-ignore\n      const dom = new window.DOMParser().parseFromString(tag.comment, 'text/html');\n      commentValue = dom.body.textContent;\n    }\n  });\n  return commentValue;\n};\nconst extractDefaultValue = property => {\n  var _a, _b;\n  try {\n    let value = (_a = property.defaultValue) === null || _a === void 0 ? void 0 : _a.replace(/^'(.*)'$/, '$1');\n    value = castDefaultValue(property, value);\n    if (value == null && ((_b = property.jsdoctags) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n      value = extractDefaultValueFromComments(property, value);\n    }\n    return value;\n  } catch (err) {\n    client_logger_1.logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n    return undefined;\n  }\n};\nconst resolveTypealias = compodocType => {\n  var _a, _b;\n  const compodocJson = exports.getCompodocJson();\n  const typeAlias = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.typealiases) === null || _b === void 0 ? void 0 : _b.find(x => x.name === compodocType);\n  return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\nexports.extractArgTypesFromData = componentData => {\n  const sectionToItems = {};\n  const compodocClasses = ['component', 'directive'].includes(componentData.type) ? ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass'] : ['properties', 'methods'];\n  compodocClasses.forEach(key => {\n    const data = componentData[key] || [];\n    data.forEach(item => {\n      const section = mapItemToSection(key, item);\n      const defaultValue = exports.isMethod(item) ? undefined : extractDefaultValue(item);\n      const type = exports.isMethod(item) || section !== 'inputs' && section !== 'properties' ? {\n        name: 'void'\n      } : exports.extractType(item, defaultValue);\n      const action = section === 'outputs' ? {\n        action: item.name\n      } : {};\n      const argType = Object.assign(Object.assign({\n        name: item.name,\n        description: item.rawdescription || item.description,\n        defaultValue,\n        type\n      }, action), {\n        table: {\n          category: section,\n          type: {\n            summary: exports.isMethod(item) ? displaySignature(item) : item.type,\n            required: exports.isMethod(item) ? false : !item.optional\n          },\n          defaultValue: {\n            summary: defaultValue\n          }\n        }\n      });\n      if (!sectionToItems[section]) {\n        sectionToItems[section] = [];\n      }\n      sectionToItems[section].push(argType);\n    });\n  });\n  const SECTIONS = ['properties', 'inputs', 'outputs', 'methods', 'view child', 'view children', 'content child', 'content children'];\n  const argTypes = {};\n  SECTIONS.forEach(section => {\n    const items = sectionToItems[section];\n    if (items) {\n      items.forEach(argType => {\n        argTypes[argType.name] = argType;\n      });\n    }\n  });\n  return argTypes;\n};\nexports.extractArgTypes = component => {\n  const componentData = getComponentData(component);\n  return componentData && exports.extractArgTypesFromData(componentData);\n};\nexports.extractComponentDescription = component => {\n  const componentData = getComponentData(component);\n  return componentData && (componentData.rawdescription || componentData.description);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","extractComponentDescription","extractArgTypes","extractArgTypesFromData","extractType","findComponentByName","checkValidCompodocJson","checkValidComponentOrDirective","getCompodocJson","setCompodocJson","isMethod","client_logger_1","require","methodOrProp","args","undefined","compodocJson","window","__STORYBOOK_COMPODOC_JSON__","component","name","Error","JSON","stringify","components","hasDecorator","item","decoratorName","decorators","find","x","mapPropertyToSection","mapItemToSection","key","c","directives","pipes","injectables","classes","getComponentData","metadata","logger","warn","displaySignature","map","arg","optional","type","join","returnType","extractTypeFromValue","defaultValue","valueType","extractEnumValues","compodocType","_a","_b","enumType","miscellaneous","enumerations","childs","every","indexOf","split","parse","e","property","resolvedType","resolveTypealias","enumValues","castDefaultValue","includes","Number","extractDefaultValueFromComments","commentValue","jsdoctags","forEach","tag","tagName","escapedText","dom","DOMParser","parseFromString","comment","body","textContent","extractDefaultValue","replace","length","err","debug","typeAlias","typealiases","rawtype","componentData","sectionToItems","compodocClasses","data","section","action","argType","assign","description","rawdescription","table","category","summary","required","push","SECTIONS","argTypes","items"],"sources":["/Users/michael.restrepo/code/personal/web-components/rimuru/node_modules/@storybook/angular/dist/ts3.9/client/docs/compodoc.js"],"sourcesContent":["\"use strict\";\n/* eslint-disable no-underscore-dangle */\n/* global window */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractComponentDescription = exports.extractArgTypes = exports.extractArgTypesFromData = exports.extractType = exports.findComponentByName = exports.checkValidCompodocJson = exports.checkValidComponentOrDirective = exports.getCompodocJson = exports.setCompodocJson = exports.isMethod = void 0;\nconst client_logger_1 = require(\"@storybook/client-logger\");\nexports.isMethod = (methodOrProp) => {\n    return methodOrProp.args !== undefined;\n};\nexports.setCompodocJson = (compodocJson) => {\n    // @ts-ignore\n    window.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n};\n// @ts-ignore\nexports.getCompodocJson = () => window.__STORYBOOK_COMPODOC_JSON__;\nexports.checkValidComponentOrDirective = (component) => {\n    if (!component.name) {\n        throw new Error(`Invalid component ${JSON.stringify(component)}`);\n    }\n};\nexports.checkValidCompodocJson = (compodocJson) => {\n    if (!compodocJson || !compodocJson.components) {\n        throw new Error('Invalid compodoc JSON');\n    }\n};\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find((x) => x.name === decoratorName);\nconst mapPropertyToSection = (item) => {\n    if (hasDecorator(item, 'ViewChild')) {\n        return 'view child';\n    }\n    if (hasDecorator(item, 'ViewChildren')) {\n        return 'view children';\n    }\n    if (hasDecorator(item, 'ContentChild')) {\n        return 'content child';\n    }\n    if (hasDecorator(item, 'ContentChildren')) {\n        return 'content children';\n    }\n    return 'properties';\n};\nconst mapItemToSection = (key, item) => {\n    switch (key) {\n        case 'methods':\n        case 'methodsClass':\n            return 'methods';\n        case 'inputsClass':\n            return 'inputs';\n        case 'outputsClass':\n            return 'outputs';\n        case 'properties':\n        case 'propertiesClass':\n            if (exports.isMethod(item)) {\n                throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n            }\n            return mapPropertyToSection(item);\n        default:\n            throw new Error(`Unknown key: ${key}`);\n    }\n};\nexports.findComponentByName = (name, compodocJson) => compodocJson.components.find((c) => c.name === name) ||\n    compodocJson.directives.find((c) => c.name === name) ||\n    compodocJson.pipes.find((c) => c.name === name) ||\n    compodocJson.injectables.find((c) => c.name === name) ||\n    compodocJson.classes.find((c) => c.name === name);\nconst getComponentData = (component) => {\n    if (!component) {\n        return null;\n    }\n    exports.checkValidComponentOrDirective(component);\n    const compodocJson = exports.getCompodocJson();\n    if (!compodocJson) {\n        return null;\n    }\n    exports.checkValidCompodocJson(compodocJson);\n    const { name } = component;\n    const metadata = exports.findComponentByName(name, compodocJson);\n    if (!metadata) {\n        client_logger_1.logger.warn(`Component not found in compodoc JSON: '${name}'`);\n    }\n    return metadata;\n};\nconst displaySignature = (item) => {\n    const args = item.args.map((arg) => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n    return `(${args.join(', ')}) => ${item.returnType}`;\n};\nconst extractTypeFromValue = (defaultValue) => {\n    const valueType = typeof defaultValue;\n    return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string'\n        ? valueType\n        : null;\n};\nconst extractEnumValues = (compodocType) => {\n    var _a, _b;\n    const compodocJson = exports.getCompodocJson();\n    const enumType = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.enumerations) === null || _b === void 0 ? void 0 : _b.find((x) => x.name === compodocType);\n    if (enumType === null || enumType === void 0 ? void 0 : enumType.childs.every((x) => x.value)) {\n        return enumType.childs.map((x) => x.value);\n    }\n    if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n        return null;\n    }\n    try {\n        return compodocType.split('|').map((value) => JSON.parse(value));\n    }\n    catch (e) {\n        return null;\n    }\n};\nexports.extractType = (property, defaultValue) => {\n    const compodocType = property.type || extractTypeFromValue(defaultValue);\n    switch (compodocType) {\n        case 'string':\n        case 'boolean':\n        case 'number':\n            return { name: compodocType };\n        case undefined:\n        case null:\n            return { name: 'void' };\n        default: {\n            const resolvedType = resolveTypealias(compodocType);\n            const enumValues = extractEnumValues(resolvedType);\n            return enumValues ? { name: 'enum', value: enumValues } : { name: 'object' };\n        }\n    }\n};\nconst castDefaultValue = (property, defaultValue) => {\n    const compodocType = property.type;\n    // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n    // null and undefined also have 'any' type\n    if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n        switch (compodocType) {\n            case 'boolean':\n                return defaultValue === 'true';\n            case 'number':\n                return Number(defaultValue);\n            case 'EventEmitter':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n    else {\n        switch (defaultValue) {\n            case 'true':\n                return true;\n            case 'false':\n                return false;\n            case 'null':\n                return null;\n            case 'undefined':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n};\nconst extractDefaultValueFromComments = (property, value) => {\n    let commentValue = value;\n    property.jsdoctags.forEach((tag) => {\n        if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n            // @ts-ignore\n            const dom = new window.DOMParser().parseFromString(tag.comment, 'text/html');\n            commentValue = dom.body.textContent;\n        }\n    });\n    return commentValue;\n};\nconst extractDefaultValue = (property) => {\n    var _a, _b;\n    try {\n        let value = (_a = property.defaultValue) === null || _a === void 0 ? void 0 : _a.replace(/^'(.*)'$/, '$1');\n        value = castDefaultValue(property, value);\n        if (value == null && ((_b = property.jsdoctags) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n            value = extractDefaultValueFromComments(property, value);\n        }\n        return value;\n    }\n    catch (err) {\n        client_logger_1.logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n        return undefined;\n    }\n};\nconst resolveTypealias = (compodocType) => {\n    var _a, _b;\n    const compodocJson = exports.getCompodocJson();\n    const typeAlias = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.typealiases) === null || _b === void 0 ? void 0 : _b.find((x) => x.name === compodocType);\n    return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\nexports.extractArgTypesFromData = (componentData) => {\n    const sectionToItems = {};\n    const compodocClasses = ['component', 'directive'].includes(componentData.type)\n        ? ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass']\n        : ['properties', 'methods'];\n    compodocClasses.forEach((key) => {\n        const data = componentData[key] || [];\n        data.forEach((item) => {\n            const section = mapItemToSection(key, item);\n            const defaultValue = exports.isMethod(item) ? undefined : extractDefaultValue(item);\n            const type = exports.isMethod(item) || (section !== 'inputs' && section !== 'properties')\n                ? { name: 'void' }\n                : exports.extractType(item, defaultValue);\n            const action = section === 'outputs' ? { action: item.name } : {};\n            const argType = Object.assign(Object.assign({ name: item.name, description: item.rawdescription || item.description, defaultValue,\n                type }, action), { table: {\n                    category: section,\n                    type: {\n                        summary: exports.isMethod(item) ? displaySignature(item) : item.type,\n                        required: exports.isMethod(item) ? false : !item.optional,\n                    },\n                    defaultValue: { summary: defaultValue },\n                } });\n            if (!sectionToItems[section]) {\n                sectionToItems[section] = [];\n            }\n            sectionToItems[section].push(argType);\n        });\n    });\n    const SECTIONS = [\n        'properties',\n        'inputs',\n        'outputs',\n        'methods',\n        'view child',\n        'view children',\n        'content child',\n        'content children',\n    ];\n    const argTypes = {};\n    SECTIONS.forEach((section) => {\n        const items = sectionToItems[section];\n        if (items) {\n            items.forEach((argType) => {\n                argTypes[argType.name] = argType;\n            });\n        }\n    });\n    return argTypes;\n};\nexports.extractArgTypes = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && exports.extractArgTypesFromData(componentData);\n};\nexports.extractComponentDescription = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && (componentData.rawdescription || componentData.description);\n};\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,2BAA2B,GAAGF,OAAO,CAACG,eAAe,GAAGH,OAAO,CAACI,uBAAuB,GAAGJ,OAAO,CAACK,WAAW,GAAGL,OAAO,CAACM,mBAAmB,GAAGN,OAAO,CAACO,sBAAsB,GAAGP,OAAO,CAACQ,8BAA8B,GAAGR,OAAO,CAACS,eAAe,GAAGT,OAAO,CAACU,eAAe,GAAGV,OAAO,CAACW,QAAQ,GAAG,KAAK,CAAC;AAC7S,MAAMC,eAAe,GAAGC,OAAO,CAAC,0BAA0B,CAAC;AAC3Db,OAAO,CAACW,QAAQ,GAAIG,YAAY,IAAK;EACjC,OAAOA,YAAY,CAACC,IAAI,KAAKC,SAAS;AAC1C,CAAC;AACDhB,OAAO,CAACU,eAAe,GAAIO,YAAY,IAAK;EACxC;EACAC,MAAM,CAACC,2BAA2B,GAAGF,YAAY;AACrD,CAAC;AACD;AACAjB,OAAO,CAACS,eAAe,GAAG,MAAMS,MAAM,CAACC,2BAA2B;AAClEnB,OAAO,CAACQ,8BAA8B,GAAIY,SAAS,IAAK;EACpD,IAAI,CAACA,SAAS,CAACC,IAAI,EAAE;IACjB,MAAM,IAAIC,KAAK,CAAE,qBAAoBC,IAAI,CAACC,SAAS,CAACJ,SAAS,CAAE,EAAC,CAAC;EACrE;AACJ,CAAC;AACDpB,OAAO,CAACO,sBAAsB,GAAIU,YAAY,IAAK;EAC/C,IAAI,CAACA,YAAY,IAAI,CAACA,YAAY,CAACQ,UAAU,EAAE;IAC3C,MAAM,IAAIH,KAAK,CAAC,uBAAuB,CAAC;EAC5C;AACJ,CAAC;AACD,MAAMI,YAAY,GAAGA,CAACC,IAAI,EAAEC,aAAa,KAAKD,IAAI,CAACE,UAAU,IAAIF,IAAI,CAACE,UAAU,CAACC,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACV,IAAI,KAAKO,aAAa,CAAC;AACtH,MAAMI,oBAAoB,GAAIL,IAAI,IAAK;EACnC,IAAID,YAAY,CAACC,IAAI,EAAE,WAAW,CAAC,EAAE;IACjC,OAAO,YAAY;EACvB;EACA,IAAID,YAAY,CAACC,IAAI,EAAE,cAAc,CAAC,EAAE;IACpC,OAAO,eAAe;EAC1B;EACA,IAAID,YAAY,CAACC,IAAI,EAAE,cAAc,CAAC,EAAE;IACpC,OAAO,eAAe;EAC1B;EACA,IAAID,YAAY,CAACC,IAAI,EAAE,iBAAiB,CAAC,EAAE;IACvC,OAAO,kBAAkB;EAC7B;EACA,OAAO,YAAY;AACvB,CAAC;AACD,MAAMM,gBAAgB,GAAGA,CAACC,GAAG,EAAEP,IAAI,KAAK;EACpC,QAAQO,GAAG;IACP,KAAK,SAAS;IACd,KAAK,cAAc;MACf,OAAO,SAAS;IACpB,KAAK,aAAa;MACd,OAAO,QAAQ;IACnB,KAAK,cAAc;MACf,OAAO,SAAS;IACpB,KAAK,YAAY;IACjB,KAAK,iBAAiB;MAClB,IAAIlC,OAAO,CAACW,QAAQ,CAACgB,IAAI,CAAC,EAAE;QACxB,MAAM,IAAIL,KAAK,CAAC,uDAAuD,CAAC;MAC5E;MACA,OAAOU,oBAAoB,CAACL,IAAI,CAAC;IACrC;MACI,MAAM,IAAIL,KAAK,CAAE,gBAAeY,GAAI,EAAC,CAAC;EAC9C;AACJ,CAAC;AACDlC,OAAO,CAACM,mBAAmB,GAAG,CAACe,IAAI,EAAEJ,YAAY,KAAKA,YAAY,CAACQ,UAAU,CAACK,IAAI,CAAEK,CAAC,IAAKA,CAAC,CAACd,IAAI,KAAKA,IAAI,CAAC,IACtGJ,YAAY,CAACmB,UAAU,CAACN,IAAI,CAAEK,CAAC,IAAKA,CAAC,CAACd,IAAI,KAAKA,IAAI,CAAC,IACpDJ,YAAY,CAACoB,KAAK,CAACP,IAAI,CAAEK,CAAC,IAAKA,CAAC,CAACd,IAAI,KAAKA,IAAI,CAAC,IAC/CJ,YAAY,CAACqB,WAAW,CAACR,IAAI,CAAEK,CAAC,IAAKA,CAAC,CAACd,IAAI,KAAKA,IAAI,CAAC,IACrDJ,YAAY,CAACsB,OAAO,CAACT,IAAI,CAAEK,CAAC,IAAKA,CAAC,CAACd,IAAI,KAAKA,IAAI,CAAC;AACrD,MAAMmB,gBAAgB,GAAIpB,SAAS,IAAK;EACpC,IAAI,CAACA,SAAS,EAAE;IACZ,OAAO,IAAI;EACf;EACApB,OAAO,CAACQ,8BAA8B,CAACY,SAAS,CAAC;EACjD,MAAMH,YAAY,GAAGjB,OAAO,CAACS,eAAe,CAAC,CAAC;EAC9C,IAAI,CAACQ,YAAY,EAAE;IACf,OAAO,IAAI;EACf;EACAjB,OAAO,CAACO,sBAAsB,CAACU,YAAY,CAAC;EAC5C,MAAM;IAAEI;EAAK,CAAC,GAAGD,SAAS;EAC1B,MAAMqB,QAAQ,GAAGzC,OAAO,CAACM,mBAAmB,CAACe,IAAI,EAAEJ,YAAY,CAAC;EAChE,IAAI,CAACwB,QAAQ,EAAE;IACX7B,eAAe,CAAC8B,MAAM,CAACC,IAAI,CAAE,0CAAyCtB,IAAK,GAAE,CAAC;EAClF;EACA,OAAOoB,QAAQ;AACnB,CAAC;AACD,MAAMG,gBAAgB,GAAIjB,IAAI,IAAK;EAC/B,MAAMZ,IAAI,GAAGY,IAAI,CAACZ,IAAI,CAAC8B,GAAG,CAAEC,GAAG,IAAM,GAAEA,GAAG,CAACzB,IAAK,GAAEyB,GAAG,CAACC,QAAQ,GAAG,GAAG,GAAG,EAAG,KAAID,GAAG,CAACE,IAAK,EAAC,CAAC;EACzF,OAAQ,IAAGjC,IAAI,CAACkC,IAAI,CAAC,IAAI,CAAE,QAAOtB,IAAI,CAACuB,UAAW,EAAC;AACvD,CAAC;AACD,MAAMC,oBAAoB,GAAIC,YAAY,IAAK;EAC3C,MAAMC,SAAS,GAAG,OAAOD,YAAY;EACrC,OAAOA,YAAY,IAAIC,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,SAAS,IAAIA,SAAS,KAAK,QAAQ,GAC5FA,SAAS,GACT,IAAI;AACd,CAAC;AACD,MAAMC,iBAAiB,GAAIC,YAAY,IAAK;EACxC,IAAIC,EAAE,EAAEC,EAAE;EACV,MAAMxC,YAAY,GAAGjB,OAAO,CAACS,eAAe,CAAC,CAAC;EAC9C,MAAMiD,QAAQ,GAAG,CAACD,EAAE,GAAG,CAACD,EAAE,GAAGvC,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAAC0C,aAAa,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,YAAY,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC3B,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACV,IAAI,KAAKkC,YAAY,CAAC;EACvP,IAAIG,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACG,MAAM,CAACC,KAAK,CAAE/B,CAAC,IAAKA,CAAC,CAAC9B,KAAK,CAAC,EAAE;IAC3F,OAAOyD,QAAQ,CAACG,MAAM,CAAChB,GAAG,CAAEd,CAAC,IAAKA,CAAC,CAAC9B,KAAK,CAAC;EAC9C;EACA,IAAI,OAAOsD,YAAY,KAAK,QAAQ,IAAIA,YAAY,CAACQ,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IACtE,OAAO,IAAI;EACf;EACA,IAAI;IACA,OAAOR,YAAY,CAACS,KAAK,CAAC,GAAG,CAAC,CAACnB,GAAG,CAAE5C,KAAK,IAAKsB,IAAI,CAAC0C,KAAK,CAAChE,KAAK,CAAC,CAAC;EACpE,CAAC,CACD,OAAOiE,CAAC,EAAE;IACN,OAAO,IAAI;EACf;AACJ,CAAC;AACDlE,OAAO,CAACK,WAAW,GAAG,CAAC8D,QAAQ,EAAEf,YAAY,KAAK;EAC9C,MAAMG,YAAY,GAAGY,QAAQ,CAACnB,IAAI,IAAIG,oBAAoB,CAACC,YAAY,CAAC;EACxE,QAAQG,YAAY;IAChB,KAAK,QAAQ;IACb,KAAK,SAAS;IACd,KAAK,QAAQ;MACT,OAAO;QAAElC,IAAI,EAAEkC;MAAa,CAAC;IACjC,KAAKvC,SAAS;IACd,KAAK,IAAI;MACL,OAAO;QAAEK,IAAI,EAAE;MAAO,CAAC;IAC3B;MAAS;QACL,MAAM+C,YAAY,GAAGC,gBAAgB,CAACd,YAAY,CAAC;QACnD,MAAMe,UAAU,GAAGhB,iBAAiB,CAACc,YAAY,CAAC;QAClD,OAAOE,UAAU,GAAG;UAAEjD,IAAI,EAAE,MAAM;UAAEpB,KAAK,EAAEqE;QAAW,CAAC,GAAG;UAAEjD,IAAI,EAAE;QAAS,CAAC;MAChF;EACJ;AACJ,CAAC;AACD,MAAMkD,gBAAgB,GAAGA,CAACJ,QAAQ,EAAEf,YAAY,KAAK;EACjD,MAAMG,YAAY,GAAGY,QAAQ,CAACnB,IAAI;EAClC;EACA;EACA,IAAI,CAAC,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,CAAC,CAACwB,QAAQ,CAACjB,YAAY,CAAC,EAAE;IACxE,QAAQA,YAAY;MAChB,KAAK,SAAS;QACV,OAAOH,YAAY,KAAK,MAAM;MAClC,KAAK,QAAQ;QACT,OAAOqB,MAAM,CAACrB,YAAY,CAAC;MAC/B,KAAK,cAAc;QACf,OAAOpC,SAAS;MACpB;QACI,OAAOoC,YAAY;IAC3B;EACJ,CAAC,MACI;IACD,QAAQA,YAAY;MAChB,KAAK,MAAM;QACP,OAAO,IAAI;MACf,KAAK,OAAO;QACR,OAAO,KAAK;MAChB,KAAK,MAAM;QACP,OAAO,IAAI;MACf,KAAK,WAAW;QACZ,OAAOpC,SAAS;MACpB;QACI,OAAOoC,YAAY;IAC3B;EACJ;AACJ,CAAC;AACD,MAAMsB,+BAA+B,GAAGA,CAACP,QAAQ,EAAElE,KAAK,KAAK;EACzD,IAAI0E,YAAY,GAAG1E,KAAK;EACxBkE,QAAQ,CAACS,SAAS,CAACC,OAAO,CAAEC,GAAG,IAAK;IAChC,IAAI,CAAC,SAAS,EAAE,cAAc,CAAC,CAACN,QAAQ,CAACM,GAAG,CAACC,OAAO,CAACC,WAAW,CAAC,EAAE;MAC/D;MACA,MAAMC,GAAG,GAAG,IAAI/D,MAAM,CAACgE,SAAS,CAAC,CAAC,CAACC,eAAe,CAACL,GAAG,CAACM,OAAO,EAAE,WAAW,CAAC;MAC5ET,YAAY,GAAGM,GAAG,CAACI,IAAI,CAACC,WAAW;IACvC;EACJ,CAAC,CAAC;EACF,OAAOX,YAAY;AACvB,CAAC;AACD,MAAMY,mBAAmB,GAAIpB,QAAQ,IAAK;EACtC,IAAIX,EAAE,EAAEC,EAAE;EACV,IAAI;IACA,IAAIxD,KAAK,GAAG,CAACuD,EAAE,GAAGW,QAAQ,CAACf,YAAY,MAAM,IAAI,IAAII,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACgC,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;IAC1GvF,KAAK,GAAGsE,gBAAgB,CAACJ,QAAQ,EAAElE,KAAK,CAAC;IACzC,IAAIA,KAAK,IAAI,IAAI,IAAI,CAAC,CAACwD,EAAE,GAAGU,QAAQ,CAACS,SAAS,MAAM,IAAI,IAAInB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACgC,MAAM,IAAI,CAAC,EAAE;MACjGxF,KAAK,GAAGyE,+BAA+B,CAACP,QAAQ,EAAElE,KAAK,CAAC;IAC5D;IACA,OAAOA,KAAK;EAChB,CAAC,CACD,OAAOyF,GAAG,EAAE;IACR9E,eAAe,CAAC8B,MAAM,CAACiD,KAAK,CAAE,oBAAmBxB,QAAQ,CAAC9C,IAAK,KAAI8C,QAAQ,CAACf,YAAa,EAAC,CAAC;IAC3F,OAAOpC,SAAS;EACpB;AACJ,CAAC;AACD,MAAMqD,gBAAgB,GAAId,YAAY,IAAK;EACvC,IAAIC,EAAE,EAAEC,EAAE;EACV,MAAMxC,YAAY,GAAGjB,OAAO,CAACS,eAAe,CAAC,CAAC;EAC9C,MAAMmF,SAAS,GAAG,CAACnC,EAAE,GAAG,CAACD,EAAE,GAAGvC,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAAC0C,aAAa,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACqC,WAAW,MAAM,IAAI,IAAIpC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC3B,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACV,IAAI,KAAKkC,YAAY,CAAC;EACvP,OAAOqC,SAAS,GAAGvB,gBAAgB,CAACuB,SAAS,CAACE,OAAO,CAAC,GAAGvC,YAAY;AACzE,CAAC;AACDvD,OAAO,CAACI,uBAAuB,GAAI2F,aAAa,IAAK;EACjD,MAAMC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,eAAe,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAACzB,QAAQ,CAACuB,aAAa,CAAC/C,IAAI,CAAC,GACzE,CAAC,iBAAiB,EAAE,cAAc,EAAE,aAAa,EAAE,cAAc,CAAC,GAClE,CAAC,YAAY,EAAE,SAAS,CAAC;EAC/BiD,eAAe,CAACpB,OAAO,CAAE3C,GAAG,IAAK;IAC7B,MAAMgE,IAAI,GAAGH,aAAa,CAAC7D,GAAG,CAAC,IAAI,EAAE;IACrCgE,IAAI,CAACrB,OAAO,CAAElD,IAAI,IAAK;MACnB,MAAMwE,OAAO,GAAGlE,gBAAgB,CAACC,GAAG,EAAEP,IAAI,CAAC;MAC3C,MAAMyB,YAAY,GAAGpD,OAAO,CAACW,QAAQ,CAACgB,IAAI,CAAC,GAAGX,SAAS,GAAGuE,mBAAmB,CAAC5D,IAAI,CAAC;MACnF,MAAMqB,IAAI,GAAGhD,OAAO,CAACW,QAAQ,CAACgB,IAAI,CAAC,IAAKwE,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,YAAa,GACnF;QAAE9E,IAAI,EAAE;MAAO,CAAC,GAChBrB,OAAO,CAACK,WAAW,CAACsB,IAAI,EAAEyB,YAAY,CAAC;MAC7C,MAAMgD,MAAM,GAAGD,OAAO,KAAK,SAAS,GAAG;QAAEC,MAAM,EAAEzE,IAAI,CAACN;MAAK,CAAC,GAAG,CAAC,CAAC;MACjE,MAAMgF,OAAO,GAAGvG,MAAM,CAACwG,MAAM,CAACxG,MAAM,CAACwG,MAAM,CAAC;QAAEjF,IAAI,EAAEM,IAAI,CAACN,IAAI;QAAEkF,WAAW,EAAE5E,IAAI,CAAC6E,cAAc,IAAI7E,IAAI,CAAC4E,WAAW;QAAEnD,YAAY;QAC7HJ;MAAK,CAAC,EAAEoD,MAAM,CAAC,EAAE;QAAEK,KAAK,EAAE;UACtBC,QAAQ,EAAEP,OAAO;UACjBnD,IAAI,EAAE;YACF2D,OAAO,EAAE3G,OAAO,CAACW,QAAQ,CAACgB,IAAI,CAAC,GAAGiB,gBAAgB,CAACjB,IAAI,CAAC,GAAGA,IAAI,CAACqB,IAAI;YACpE4D,QAAQ,EAAE5G,OAAO,CAACW,QAAQ,CAACgB,IAAI,CAAC,GAAG,KAAK,GAAG,CAACA,IAAI,CAACoB;UACrD,CAAC;UACDK,YAAY,EAAE;YAAEuD,OAAO,EAAEvD;UAAa;QAC1C;MAAE,CAAC,CAAC;MACR,IAAI,CAAC4C,cAAc,CAACG,OAAO,CAAC,EAAE;QAC1BH,cAAc,CAACG,OAAO,CAAC,GAAG,EAAE;MAChC;MACAH,cAAc,CAACG,OAAO,CAAC,CAACU,IAAI,CAACR,OAAO,CAAC;IACzC,CAAC,CAAC;EACN,CAAC,CAAC;EACF,MAAMS,QAAQ,GAAG,CACb,YAAY,EACZ,QAAQ,EACR,SAAS,EACT,SAAS,EACT,YAAY,EACZ,eAAe,EACf,eAAe,EACf,kBAAkB,CACrB;EACD,MAAMC,QAAQ,GAAG,CAAC,CAAC;EACnBD,QAAQ,CAACjC,OAAO,CAAEsB,OAAO,IAAK;IAC1B,MAAMa,KAAK,GAAGhB,cAAc,CAACG,OAAO,CAAC;IACrC,IAAIa,KAAK,EAAE;MACPA,KAAK,CAACnC,OAAO,CAAEwB,OAAO,IAAK;QACvBU,QAAQ,CAACV,OAAO,CAAChF,IAAI,CAAC,GAAGgF,OAAO;MACpC,CAAC,CAAC;IACN;EACJ,CAAC,CAAC;EACF,OAAOU,QAAQ;AACnB,CAAC;AACD/G,OAAO,CAACG,eAAe,GAAIiB,SAAS,IAAK;EACrC,MAAM2E,aAAa,GAAGvD,gBAAgB,CAACpB,SAAS,CAAC;EACjD,OAAO2E,aAAa,IAAI/F,OAAO,CAACI,uBAAuB,CAAC2F,aAAa,CAAC;AAC1E,CAAC;AACD/F,OAAO,CAACE,2BAA2B,GAAIkB,SAAS,IAAK;EACjD,MAAM2E,aAAa,GAAGvD,gBAAgB,CAACpB,SAAS,CAAC;EACjD,OAAO2E,aAAa,KAAKA,aAAa,CAACS,cAAc,IAAIT,aAAa,CAACQ,WAAW,CAAC;AACvF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}