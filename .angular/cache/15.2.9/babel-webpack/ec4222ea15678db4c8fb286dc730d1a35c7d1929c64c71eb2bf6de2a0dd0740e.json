{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.function.name.js\";\nvar STORY_KIND_PATH_SEPARATOR = /\\s*\\/\\s*/;\nexport var storySort = function storySort() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (a, b) {\n    // If the two stories have the same story kind, then use the default\n    // ordering, which is the order they are defined in the story file.\n    // only when includeNames is falsy\n    if (a.title === b.title && !options.includeNames) {\n      return 0;\n    } // Get the StorySortParameter options.\n\n    var method = options.method || 'configure';\n    var order = options.order || []; // Examine each part of the story title in turn.\n\n    var storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR);\n    var storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);\n    if (options.includeNames) {\n      storyTitleA.push(a.name);\n      storyTitleB.push(b.name);\n    }\n    var depth = 0;\n    while (storyTitleA[depth] || storyTitleB[depth]) {\n      // Stories with a shorter depth should go first.\n      if (!storyTitleA[depth]) {\n        return -1;\n      }\n      if (!storyTitleB[depth]) {\n        return 1;\n      } // Compare the next part of the story title.\n\n      var nameA = storyTitleA[depth];\n      var nameB = storyTitleB[depth];\n      if (nameA !== nameB) {\n        // Look for the names in the given `order` array.\n        var indexA = order.indexOf(nameA);\n        var indexB = order.indexOf(nameB);\n        var indexWildcard = order.indexOf('*'); // If at least one of the names is found, sort by the `order` array.\n\n        if (indexA !== -1 || indexB !== -1) {\n          // If one of the names is not found and there is a wildcard, insert it at the wildcard position.\n          // Otherwise, list it last.\n          if (indexA === -1) {\n            if (indexWildcard !== -1) {\n              indexA = indexWildcard;\n            } else {\n              indexA = order.length;\n            }\n          }\n          if (indexB === -1) {\n            if (indexWildcard !== -1) {\n              indexB = indexWildcard;\n            } else {\n              indexB = order.length;\n            }\n          }\n          return indexA - indexB;\n        } // Use the default configure() order.\n\n        if (method === 'configure') {\n          return 0;\n        } // Otherwise, use alphabetical order.\n\n        return nameA.localeCompare(nameB, options.locales ? options.locales : undefined, {\n          numeric: true,\n          sensitivity: 'accent'\n        });\n      } // If a nested array is provided for a name, use it for ordering.\n\n      var index = order.indexOf(nameA);\n      order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : []; // We'll need to look at the next part of the name.\n\n      depth += 1;\n    } // Identical story titles. The shortcut at the start of this function prevents\n    // this from ever being used.\n\n    /* istanbul ignore next */\n\n    return 0;\n  };\n};","map":{"version":3,"names":["STORY_KIND_PATH_SEPARATOR","storySort","options","arguments","length","undefined","a","b","title","includeNames","method","order","storyTitleA","trim","split","storyTitleB","push","name","depth","nameA","nameB","indexA","indexOf","indexB","indexWildcard","localeCompare","locales","numeric","sensitivity","index","Array","isArray"],"sources":["/Users/michael.restrepo/code/personal/web-components/rimuru/node_modules/@storybook/store/dist/esm/storySort.js"],"sourcesContent":["import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.function.name.js\";\nvar STORY_KIND_PATH_SEPARATOR = /\\s*\\/\\s*/;\nexport var storySort = function storySort() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (a, b) {\n    // If the two stories have the same story kind, then use the default\n    // ordering, which is the order they are defined in the story file.\n    // only when includeNames is falsy\n    if (a.title === b.title && !options.includeNames) {\n      return 0;\n    } // Get the StorySortParameter options.\n\n\n    var method = options.method || 'configure';\n    var order = options.order || []; // Examine each part of the story title in turn.\n\n    var storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR);\n    var storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);\n\n    if (options.includeNames) {\n      storyTitleA.push(a.name);\n      storyTitleB.push(b.name);\n    }\n\n    var depth = 0;\n\n    while (storyTitleA[depth] || storyTitleB[depth]) {\n      // Stories with a shorter depth should go first.\n      if (!storyTitleA[depth]) {\n        return -1;\n      }\n\n      if (!storyTitleB[depth]) {\n        return 1;\n      } // Compare the next part of the story title.\n\n\n      var nameA = storyTitleA[depth];\n      var nameB = storyTitleB[depth];\n\n      if (nameA !== nameB) {\n        // Look for the names in the given `order` array.\n        var indexA = order.indexOf(nameA);\n        var indexB = order.indexOf(nameB);\n        var indexWildcard = order.indexOf('*'); // If at least one of the names is found, sort by the `order` array.\n\n        if (indexA !== -1 || indexB !== -1) {\n          // If one of the names is not found and there is a wildcard, insert it at the wildcard position.\n          // Otherwise, list it last.\n          if (indexA === -1) {\n            if (indexWildcard !== -1) {\n              indexA = indexWildcard;\n            } else {\n              indexA = order.length;\n            }\n          }\n\n          if (indexB === -1) {\n            if (indexWildcard !== -1) {\n              indexB = indexWildcard;\n            } else {\n              indexB = order.length;\n            }\n          }\n\n          return indexA - indexB;\n        } // Use the default configure() order.\n\n\n        if (method === 'configure') {\n          return 0;\n        } // Otherwise, use alphabetical order.\n\n\n        return nameA.localeCompare(nameB, options.locales ? options.locales : undefined, {\n          numeric: true,\n          sensitivity: 'accent'\n        });\n      } // If a nested array is provided for a name, use it for ordering.\n\n\n      var index = order.indexOf(nameA);\n      order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : []; // We'll need to look at the next part of the name.\n\n      depth += 1;\n    } // Identical story titles. The shortcut at the start of this function prevents\n    // this from ever being used.\n\n    /* istanbul ignore next */\n\n\n    return 0;\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}